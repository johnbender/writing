---
layout: post
title: System F in CoffeeScript
tags:
- coffeescript
- math
status: draft
type: post
published: true
listed: false
vote: "CHANGE"
meta:
  _edit_last: "1"
---

System F is a variant of the Lambda Calculus. It "mixes" types and terms relatively freely compared with the average statically typed programming language. System F and it's variants are used frequently in the study of typed computation and an extended form, System FC, plays an important role in GHC's compilation process [1]. This post will translate the grammars of the Lambda Calculus, Simply Typed Lambda Calculus, and finally System F into a small subset of CoffeeScript while covering the basics of application and abstraction in each.

## Lambda Calculus

Representing the Lambda Calculus only requires a small subset of CoffeeScript's total synatx. Let's define both grammars side by side.

!! insert image of lambda calculus and coffeescript

In both cases `x` represents a variable and `t t` represents application of one term to another. The only real difference is the lambda abstraction syntax.

!! insert image of abstraction examples

In the Lambda Calculus, abstraction involves preceding or wrapping a term `t` with `λx.t` which captures or defines the variable `x` inside the term `t`. In the example `t` is `λx.y`, using the abstraction `λy.t` creates a new term `λy.λx.y` (otherwise known as the K-combinator). Note that the `x` in `λx.t` could be any variable like `y` in the example.

In CoffeeScript the same initial term is `(x) -> y` and applying the CoffeeScript version of abstraction yields `(y) -> (x) -> y`. Viewing the <a href="http://coffeescript.org/#try:(y)%20-%3E%20(x)%20-%3E%20y">translation</a> to JavaScript is informative. More importantly, both behave the same way when applied to a single argument.

!! insert image of application to identity

The application of a term that takes two arguments (`y` and `x`) to a single term/argument results in a lambda that can be applied to another term. The <a href="http://coffeescript.org/#try:console.log%20((y)%20-%3E%20(x)%20-%3E%20y)%20((x)%20-%3E%20y)">translation</a> to JavaScript shows that a function object is returned ready for application.

The notion of _closed_ terms in the Lambda Calculus is a point of departure with CoffeeScript. A closed term has no free variables. For example, in `λx.y` the `y` variable is called _free_ because it hasn't been bound by an enclosing abstractions. Adding an additional abstraction to get `λy.λx.y` captures the `y`. The JavaScript generated by the CoffeeScript `(x) -> y` will throw a reference error without a definition for `y` in scope, in constrast to the lambda term which will simply discard it's argument and produce the `y`.

## Simply Typed Lambda Calculus

The Simply Typed Lambda Calculus expands on the Lambda Calculus with type information in abstractions. The grammar alterations for it and the CoffeeScript equivalent are as follows:

!! Insert image of extended grammars

It adds a type requirement to the argument of abstractions. The CoffeeScript equivalent requires a function that compares a type argument to the argument term. To keep things simple, `ifft` will throw an exception when the types don't line up. This is will be more interesting later with System F when the type `τ` can be defined after the fact instead of inside or with the abstraction.

```coffeescript
# If and only if (iff) the type (t) is correct
ifft = (type, obj) ->
  if obj instanceof type
    throw "Type mismatch"
```

This definition assumes that the browser's `instanceof` implementation is behaving properly but certainly serves the purpose here. Assuming the type `Foo` is defined for the calculus and with `class Foo` in the CoffeeScript.

!! Insert image of identity function with Foo type expectation

There's a larger discussion to be had about how the types are used in both Simply Typed Lambda Calculus and CoffeeScript. In the CoffeeScript it's very much a delayed form of typing but in the Lambda Calculus it defines the term and it's capabilities [2].

## System F

System F adds a lot of additional capability to the Simply Typed Lambda Calculus but primarily it introduces the notion of _polymorphic types_.

### Footnotes

1. There are some [interesting papers](http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/) to read from Microsoft Research this particular extension of System F.
2. This is a more [intrinsic](http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus#Intrinsic_vs._extrinsic_interpretations) approach to the translation as we aren't attempting to use types to reason about the terms/grammars.
