---
layout: post
title: System State and Declarative Languages
tags:
- sql
- devops
status: published
type: post
published: true
listed: false
---

Declartive programming languages are often characterized by how they express computation in terms of a desired outcome. This is in contrast to imperative languages which are often seen, vis-a-vis declarative languages, as expressing computation with series of steps to reach an outcome. The advantages of the declarative approach are clear, the program author states his or her intentions and the rest is left to the runtime [1]. In practice many of the languages that earn the declarative label encode much of the *how* into syntax out of necessity.

In this post

Declarative programming appears to be riding the coat-tails of functional programming into the lime light as an alternative to imperative style programming.

Languages like Erlang and Haskell are often labelled as "declarative" because the programmer is more closely representing their intentions in place of representing how to achieve those intentions, though their

SQL has long been the poster child for the benefits of defining *what* instead of *how* years but recent interest in logic programming and system configuration tools has brought new attention to


## Semantic Dual


### footnotes

1. "It seems like a sufficiently advanced runtime...", famous last words from an anonymous PhD dropout.
