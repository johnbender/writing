---
layout: post
title: "Why I'm getting a PhD"
tags:
- career
- education
status: published
type: post
published: true
listed: false
vote: http://news.ycombinator.com/newest
---

The 26th is the first day of instruction in the first academic year of my PhD in Computer Science at UCLA. I have a daughter, an incredibly supportive wife, and I just turned 30. It should come as no surprise then that I've been asked, variously by my mother, friends, and colleagues, why I want to get a PhD but I rarely get a chance to explain my thinking completely. Hopefully this post will serve as a better account of why I'm pursuing a PhD and as a weak counterpoint to the popular opinion that there isn't much value in higher education in Computer Science.

## Why Bother?

Whenever someone is confused or surprised by my decision to go back to school it seems to boil down to one reasonable idea: any professional success I would otherwise have garnered while getting my PhD is of greater absolute value than the education I will be getting.

This comes in many reasonable forms. Why are you leaving such a high paying job? Will you be able to speak at conferences? When will you find time to contribute to open source? Couldn't you just work on those ideas in your free time? These questions are asked directly and with out implication.

In some cases there is a subtle suggestion that academia and higher eduction are loosing their "value". Why would you pursue a PhD when there are people without any higher education earning comparable salaries and working on important projects? I never hear this asked straight out, but it comes through in a lot of my conversations and the idea that education isn't important is pervasive in the software "meritocracy".

Regardless of any underlying prejudice I'm consistently left wanting more time to describe the process and the personal experiences which landed me in a PhD program.

## Career Path

When I got my first legitimate management position as the director of engineer at a consultancy/incubator it became clear very quickly that management wasn't for me. I enjoyed seeing my teammates succeed. I enjoyed building and refining Process. I enjoyed winning business. I enjoyed the subtleties of communicating complex technical ideas to people with all types of backgrounds and experience.

The thing that really got to me was the amount of time I spent staring at my email client. After a year I really missed the technical aspects of the job, and I started to think about my long term career options.

As I see it there are three paths you can take that don't route back through school, when you are up for a management position.

1. **Avoid title and stick with engineering** This was, at least initially, the path I took. I left for Adobe and a position working full time on jQuery Mobile.
2. **Grab the title and climb the ladder** Management positions pay a lot of money, and there's a lot of room for advancement. Not all require you to hand over your keyboard.
3. **Employee Number One or Co-Founder** First employee/Co-Founder positions are available for experienced "generalists" as far as I can tell. This is purely based on personal observations and conversation with friends who are better informed on the topic.

Of course, There are a lot of subtle variants to these larger themes but this was my assessment. I can say with confidence that my move to Adobe put me in a seemingly ideal engineering position. Working on an OSS project full time gave me the freedom to pursue long term solutions to difficult problems that were affecting the project and I still had access to "the good parts" of a large corporate support infrastructure.

Prior to joining Adobe though it was clear that none of these options quite fit. The problems I gravitate towards are *not* of interest to potential employers. My attempts to marry my interests and my domain of expertise [1,2] have resulted in understandably tepid responses. The ideas are hard to follow in short presentations, most people don't have time to read marathon blog posts, and only the presentation were funded by my employer, not the underlying work. All of that makes perfect sense but all of it also means less time for those types of problems.

## What Interests Me

The things that keep me up past midnight working and learning are technical. Problems both large and small that remain unsolved or problems where the solution seems unsatisfactory. A short and incomplete list in no particular order:

* Descriptive declarative languages that aren't
* Correctness in dynamic languages
* System configuration and state management
* Adoption, understanding, and value of advanced type systems
* Direct applications of mathematics to programming languages
* Semantics based approaches to hot code loading
* Preventing language bugs/quirks during language creation

A few of these might align with a job posting somewhere but most don't. More importantly, I'm not as interested in the implementation as I am in conceiving a solution and understanding it's value. I'm sure that will sound like laziness to some, but the part I enjoy the most is thinking through the idea thoroughly. Most of the time an implementation is an important part of that, and I enjoy hacking as much as anyone, but sometimes it's not. Sometimes a more abstract representation of the problem is the best way to predict the relative value of a solution before committing time and effort to an implementation.

## On Academia

Perception of academia varies depending on the field and an individual's cultural disposition. You can regularly find pundits on Fox News raging against academics and self-interest where climate change is concerned. Others are quite enamored of esoteric approaches to program specification that, in my estimation, discount how developers actually write software in the interest of purity and soundness.

The software development community generally falls somewhere in the middle. There is a vague sense of respect for the research and science on which our careers are built. People have even sort of deified greats like Alan Kay, Alonzo Church, and Alan Turing. At least in the case of Alan Kay, they frequently appeal to his authority.

More and more though, the word "academic" is being used as a pejorative to mean irrelevant, unimportant, or a wasted effort. It's easy to wave this away as an issue of sloppy semantics but I think it highlights the suffering perception of academics.

In my experience working on research projects and doing a lot of reading over the last few years, much of the stigma appears to result from two issues. The first is, what people think research should be for, and the second is the occasionally impenetrable nature of formalism.

Computer Science research is frequently accompanied by proof of concept software. Many times it's poorly constructed or at least hard to get working, which can lead to a poor opinion of the research and researchers. This is understandable until you realize that implementations are rarely the primary contribution of the work that inspired them. This is one consequence of an important fact: the goal of the researchers is *not* to provide implementations or information directly to industry but rather to produce a solution to an outstanding problem. The work of translating that solution into something "well built" or even concrete is frequently left to the interested reader.

If by chance you're one of those readers and you lack an academic background, you know how hard it can be to get anything out of a published paper. The deluge of notation can be discouraging and it can even seem like unnecessary ceremony. Again, this is understandable but for the amount of ground that has to be covered in a limited number of publication formatted pages. Moreover, formalism and logic are the most important tools we have when coming to consensus on what is actually a "good" solution to a complex problem. In a perfect world all the necessary context would be easily accessible, and the formal tools used to establish the desired properties of a solution would be easy to understand. Sadly, that's not the case, but that doesn't diminish the value of the "encoded" contribution.

For me it's *because* of these two things and not in spite of them that I'm returning to school. I want to work in an environment that explicitly promotes a focus on the fundamentals of very difficult problems and requires that the utmost care be taken when presenting solutions. I want to focus on the problem itself and worry less [4] about software implementation details.

## The Fourth Path

I'm taking The Fourth Pathâ„¢.

It's likely that many of the ideas presented here are colored by inexperience in the academic environment. Though, in my defense, I have been working on research projects since last year with folks at UCLA and I have been attending regular reading groups. Even better I have a very good idea of the problems I want to work on, one of which I'm pursuing with a strong blessing from my adviser.

Even if this turns out to be a monumental disaster, I know I'm attempting something that fits and that's why I'm getting my PhD.

<br/>
<br/>

### Footnotes

1. [Presentation: Faster JavaScript through Category Theory](/2013/08/29/presentation-faster-javascript-through-category-theory/)
2. [Presentation: Math Envy and CoffeeScript's Foibles](/2013/07/19/presentation-math-envy-and-coffeescripts-foibles/)
3. [Promisegate](https://github.com/promises-aplus/promises-spec/issues/94)
4. *Less* is not, *not at all*

I had originally intended to include this in the main body of the post but it seemed like a distraction:

As a web developer and someone who's worked almost exclusively on the client side for the last few years I have a fairly long list of things that do not interest me or are an active source of frustration. Nearly all of them would be impossible to describe as "general" problems.

* Esoteric browser bugs (yes they still exist in abundance)
* The culture/necessity of JavaScript micro-libraries
* Effort required to provide broad access to web based content
* Dynamic programming languages as an industry default
* Non-transferable esoterica (e.g., how iptables works on CentOS, Chef's attribute resolution order)
* Large JavaScript projects

I'm not above working on, or around, these problems. For a web developer many of these are simply facts of life. I'm just not content to let them bother me indefinitely which means contributing to solutions or moving on.
