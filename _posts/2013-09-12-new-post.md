---
layout: post
title: "Why I'm getting a PhD"
tags:
- career
- education
status: published
type: post
published: true
listed: false
vote: http://news.ycombinator.com/newest
---

The 26th is the first day of instruction in the first academic year of my PhD in Computer Science at UCLA. I've been asked, variously by my mother, friends, and colleagues, why I want to get a PhD but I rarely get a chance to explain my thinking completely. Hopefully this post will serve as a better account of why I'm pursuing a PhD and as a weak counterpoint to the fairly popular opinion that there isn't much value to academia and higher education in Computer Science and engineering.

## Why Bother?

Whenever someone is confused or surprised by my decision to go back to school it seems to boil down to one, relatively reasonable idea: any professional success I would otherwise have garnered while getting my PhD are of greater absolute value than the education I will be getting.

This comes in many reasonable forms. Why are you leaving such a high paying job? Will you be able to speak at conferences? When will you find time to contribute to open source? Couldn't you just work on those ideas in your free time? These questions are generally asked directly and with genuine interest in the response.

In some cases there is a subtle implication that academia and higher eduction are loosing a their "value". Why would you pursue a PhD when there are people without any higher education earning comparable salaries and working on important projects? I never hear this asked straight out, but it comes through in a lot of my conversations and the idea that education is unimportant is pervasive in the software "meritocracy".

Regardless of any underlying prejudice I'm consistently left wanting more time to describe the process and most importantly the personal experience by which I decided on a PhD.

## Career Path

When I got my first legitimate management position as the director of engineer at a consultancy/incubator it became clear very quickly that management wasn't for me. I enjoyed seeing my teammates succeed. I enjoyed building and refining our process. I enjoyed winning business. I enjoyed the subtleties of communicating complex technical ideas to people with all types of backgrounds and experience.

The thing that really got to me was the amount of time I spent staring at my email client. After about a year I really missed the technical aspects of the job, and I started to think about my long term career options.

As I see it, there are three paths you can take when you are up for management positions that don't route back through school.

1. **Avoid title advancement and stick with engineering** This was, at least initially, the path I took. I left for Adobe and a position working full time on jQuery Mobile.
2. **Grab the title and climb the ladder** Management positions pay a lot of money, and there's a lot of room for advancement. Not all require you to hand over your keyboard.
3. **Employee Number One or Co-Founder** First employee/Co-Founder positions are available for experienced "generalists" as far as I can tell. This is purely based on personal observations and conversation with friends who are better informed on the topic.

Of course, There are a lot of subtle variants to these larger themes but this was my assessment. I can say with confidence that my move to Adobe put me in a seemingly ideal engineering position. Working on an OSS project full time gave me the freedom to pursue long term solutions to difficult problems that were affecting the project and I still had access to "the good parts" of a large corporate support infrastructure.

Prior to joining Adobe though it was clear that I wanted to go back to school. The problems I gravitate towards aren't *not* of interest to potential employers. My attempts to marry my interests and my domain of expertise [1,2] have resulted in understandably tepid responses. The ideas are hard to follow in short presentations and most people don't have time to read marathon blog posts, but these are still the types of problems that interest me.

## What Interests Me

The things that keep me up past midnight working and learning are technical. Problems both large and small that remain unsolved or where the solution seems unsatisfactory. A short and incomplete list in no particular order:

* Descriptive declarative languages that aren't
* Correctness in dynamic languages
* System configuration and state management
* Adoption, understanding, and value of advanced type systems
* Direct applications of mathematics to programming languages
* Semantics based approaches to hot code loading
* Preventing language bugs/quirks during language creation

A few of these might align with a job posting somewhere but most don't. More importantly, I'm not as interested in the implementation as I am in conceiving a solution and understanding it's value. I'm sure that will sound like laziness to some, but the part I enjoy the most is thinking through the idea completely. Most of the time an implementation is an important part of that, and I enjoy hacking as much as anyone, but sometimes it's not. Sometimes a more abstract representation of the problem is the best way to predict the relative value of a solution before committing time and effort to an implementation

## On Academia

Perception of academia varies depending on the field and an individual's cultural disposition. You can regularly find pundits on Fox News raging against academics and self-interest where climate change is concerned. Others are quite enamored of esoteric approaches to program specification that, in my estimation, discount how developers actually write software in the interest of purity and soundness.

The software development community generally falls somewhere in the middle. There is a vague sense of respect for the research and science on which our careers are built. People have even sort of deified greats like Alan Kay, Alonzo Church, and Alan Turing. At least in the case of Alan Kay, they frequently appeal to his authority.

More and more though, the word "academic" is being used as a pejorative among software developers, to mean irrelevant, unimportant, or focused improperly. It's easy to wave this away as an issue of sloppy semantics but I think it highlights the suffering perception of academia and education.

In my experience working on research projects and doing a lot of reading over the last year this stigma appears to result from two main issues. The first is what people think research should be for, and the second is the occasionally impenetrable nature of formalism.

Computer Science research is frequently accompanied by proof of concept software. Many times it's poorly constructed or at least hard to get working, which can lead to a poor opinion of the research and researchers. This is understandable until you realize that tool implementations are rarely the primary contribution of the work that inspired them. More broadly, the goal of the researchers is *not* to provide tools or information directly to industry but rather to explore a solution to an outstanding problem. The work of translating that solution into something concrete is frequently left to the interested reader.

If by chance you're one of readers and you lack an academic background, you know how hard it can be. The deluge of notation can be discouraging and can even seem like unnecessary ceremony. Again, this is understandable until you realize that the amount of ground that has to be covered in a limited number of publication formatted pages demands extreme economy. Moreover, formalism, notation and logic are the most important tools we have when coming to consensus on what is actually a "good" solution to a problem. In a perfect world all the necessary context would be easily accessible, and the formal tools used to establish desired the properties of a solution would be easy to understand. Sadly, that's not the case, but that doesn't diminish the value of the "encoded" contribution.

## The Fourth Path

TODO conclusion

### Footnotes

1. [Presentation: Faster JavaScript through Category Theory](/2013/08/29/presentation-faster-javascript-through-category-theory/)
2. [Presentation: Math Envy and CoffeeScript's Foibles](/2013/07/19/presentation-math-envy-and-coffeescripts-foibles/)
3. [Promisegate]()

I had originally intended to include this in the main body of the post but it seemed like a distraction:

As a web developer and someone who's worked almost exclusively on the client side for the last few years I have a fairly long list of things that do not interest me or are an active source of frustration. Nearly all of them would be impossible to describe as "general" problems.

* Esoteric browser bugs (yes they still exist in abundance)
* The culture/necessity of JavaScript micro-libraries
* Effort required to provide broad access to web based content
* Dynamic programming languages as an industry default
* Non-transferable esoterica (e.g., how iptables works on CentOS, Chef's attribute resolution order)
* Large JavaScript projects

I'm not above working on, or around, these problems. For a web developer many of these are simply facts of life. I'm just not content to let them bother me indefinitely which means contributing to solutions or moving on.
